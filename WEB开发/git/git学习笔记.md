---
title: "git学习笔记"
date: 2020-01-17T11:51:28+08:00
description: ""
lastmod: 2018-07-10T00:00:00+08:00
draft: false
tags: ["git"]
categories: ["git"]

weight: 1
contentCopyright: MIT
mathjax: true
autoCollapseToc: true
---
## 2016.7.11
- 本地版本控制类似于文件打补丁；集中化的版本控制，都有单一的集中管理的服务器，而客户端连接这台服务器，取出最新的文件或者提交更新，缺点是单点故障；分布式版本控制客户端把原始的代码仓库完整的镜像下来。
- 2002年，linux项目组开始启用分布式版本控制系统BitKeeper；2005年，BitKeeper和linux社区合作关系结束，迫使linux社区自己开发版本控制系统，git自2005年诞生以来日臻成熟。
- git和其他版本控制系统的主要差别在于，git只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体变化。git更像是把变化的文件做快照。
- git几乎绝大多数的操作都是在本地执行。
- git时刻保持数据完整性，git使用SHA-1算法计算数据和校验。此根据文件内容或目录结构计算出的哈希值用作索引，而不是文件名。
- 如果 git clone 出来的话，就是其中 .git 的目录；如果 git clone --bare 的话，新建的目录本身就是 Git 目录。
- 一般状态分为"未暂存"、"已暂存"、"已提交"。"已提交"的文件修改后就是"未暂存"状态，"未暂存"的文件add后就是“未提交”状态，commit之后就是“已提交状态”。git diff可以看未暂存状态的差异，git diff --staged可以看未提交状态
- git rm log/\*.log和git rm \*~。注意\*表示递归。
   
## 2016.7.12
- gitk命令可以启动图形化界面
- git轻量级标签实际上是个指向特定提交对象的引用，而含附注标签实际是存储在仓库中的一个独立对象，有自身的校验和信息。
- git的自动完成，mac和linux系统都要配置，windows已经配置好了，按下两个tab键即可
- git别名设置很有用，比如：git config --global alias.last 'log -1 HEAD'就可以查看最后一次提交的信息。
- git分支实际上仅是一个包含所指对象校验和（40个字符长度SHA-1字符串）的文件。
- 一般使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁 ：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的origin/master 进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作
- git提交时用合并基本上没有问题，但用衍合最好针对那些尚未公开的提交对象，一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。

## 2016.7.13
- git可以使用4种主要的协议来传输数据：本地传输、SSH协议、git协议和HTTP协议。除了http协议外，其他的所有协议都要求在服务器端安装并运行git。
- git传输协议中最常见的就是SSH了，SSH也是唯一一个同时支持读写操作的网络协议；而HTTP和Git通常是只读的。
- SSH的缺点在于不能通过它实现仓库的匿名访问。
- HTTP传输的消极一面是客户端效率更低，克隆或者下载仓库内容可能花费更多时间，而且HTTP传输的体积和网络开销比其他任何一个协议都大。

1、写接口返回值最好是对象，不用是基本类型，也不要是list，以便于扩展。
2、枚举不用缓存，主要是反序列化的问题。

## 2016.9.21
### git diff
- 若后面带有hash值，则表示相对于hash值状态所做的修改
  - 如git diff c859g8, git diff head, git diff origin/dev
  
- 若后面不带hash值，则表示当前状态的相对于初始文件所做的修改
  - 如git diff(未暂存区), git diff --cached(暂存区)
  - 注意：初始文件状态不是head指向的状态：如从head文件开始（状态A），做了一次修改并暂存（状态B），再做一次修改不暂存（状态C）。那么git diff --cached就是B状态相对于A状态的修改，git diff --cached就是C状态相对于B状态的修改。
  - 总结而言：git diff是未暂存区相对于暂存区而已，git diff --cached是暂存区相对于head而言。
  
### 换行符
- 若文件一开始是windows换行符，后要改成unix换行符。这个时候打开文件还是win的，拉取代码若不产生冲突则还是win的，但产生了冲突后，新增进来的代码就是uninx的了。

### 技术说明
- 文件内容并没有真正存储在索引(.git/index)或者提交对象中，而是以blob的形式分别存储在数据库中(.git/objects)，并用SHA-1值来校验。

- 索引文件用识别码列出相关的blob文件以及别的数据。

- 对于提交来说，以树(tree)的形式存储，同样用对于的哈希值识别。树对应着工作目录中的文件夹，树中包含的 树或者blob对象对应着相应的子目录和文件。每次提交都存储下它的上一级树的识别码。

- 如果用detached HEAD提交，那么最后一次提交会被the reflog for HEAD引用。但是过一段时间就失效，最终被回收，与git commit --amend或者git rebase很像。
