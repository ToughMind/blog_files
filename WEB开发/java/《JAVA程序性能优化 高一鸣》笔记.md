---
title: "《JAVA程序性能优化 高一鸣》笔记"
date: 2020-01-17T11:51:28+08:00
description: ""
lastmod: 2018-07-10T00:00:00+08:00
draft: false
tags: ["java"]
categories: ["java"]

weight: 1
contentCopyright: MIT
mathjax: true
autoCollapseToc: true
---
## 2016.12.7
### 善用单例模式

- 普通的单例模式，在属性中就实例化了对象，使得在使用该单例类的其他方法时也实例化了该对象。
- 若把实例化工作放入到getInstance方法中，则一定要加同步，降低了性能。
- 序列化和反序列化有可能破坏单例，利用readResolve方法可以解决。

## 2016.12.8
### 代理模式
- 在系统启动时，将消耗资源最多的方法都使用代理模式分离（延迟加载）
- 延迟加载：若当前没有使用该组件，则不需要真正初始化，使用一个代理对象代替其位置；真正需要使用时，才对该组件进行加载。
- 动态代理使用了字节码动态生成加载技术，在运行时生成并加载类。
  - JDK功能最弱，CGLIB和Javassist功能强大，ASM性能最好，但很繁琐，维护性差。
- 动态代理的主逻辑：根据指定的回调类生成Class字节码 -- 通过defineClass()将字节码定义为类 -- 使用反射机制生成该类的实例。 
- hibernate中对实体类的动态代理模式是用于延迟加载的经典实现。
  - 在load对象时，并未初始化所有对象信息（未走数据库），而是使用动态代理（cglib）子类替代。在真正使用对象数据时，才去数据库加载实际的数据。 
  
