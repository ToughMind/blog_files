---
title: "IO学习"
date: 2020-01-17T11:51:28+08:00
description: ""
lastmod: 2018-07-10T00:00:00+08:00
draft: false
tags: ["linux"]
categories: ["linux"]

weight: 1
contentCopyright: MIT
mathjax: true
autoCollapseToc: true
---
### 1、IO发生的步骤
- 网络IO的本质是socket的读取，socket在linux系统被抽象为流
- 对于一个network IO (以read举例)，涉及两个对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。
  - 等待数据准备
  - 将数据从内核拷贝到进程中
- 对于socket流
  - 通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区
  - 把数据从内核缓冲区复制到应用进程缓冲区
  
### 2、5种IO模型，blocking IO、 nonblocking IO、 IO multiplexing、signal driven IO、asynchronous IO
- 同步模型：阻塞IO，非阻塞IO，多路复用IO，信号驱动IO。异步模型。
  - 同步模型中，都是进程主动等待内核检查状态。
- blocking IO：在IO执行的两个阶段都被block了
![image](https://static.oschina.net/uploads/img/201604/20150405_VKYH.png)
- nonblocking IO
  - 轮询（polling）方式
  - 用户进行read操作，若内核没有准备好，会立即返回error
  - 用户进程需要不断主动询问内核数据是否准备好
- IO multiplexing（event driven IO）
  - select调用时内核级别的，可以监听多个socket
  - 基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。
  - 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket
![image](https://static.oschina.net/uploads/img/201604/20164149_LD8E.png)
- asynchronous IO
  - 从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，然后，kernel会完成一切并给用户进程发送一个signal，告诉它read操作完成了。
![image](https://static.oschina.net/uploads/img/201604/20175459_gtgw.png)

### 2.2、五种模型的总结
- 同步非阻塞相比同步阻塞可以多个任务同时执行，但完成任务响应延迟增大。
- 多路复用IO使得单线程情况下可以处理多个客户端请求。系统开销小，不需要新建线程。
- select 函数所提供的功能（异步阻塞 IO）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞
- linux中异步通知的方式是信号（还可以是回调函数）
  - 若进程在做别的事，强行打算，调用事先注册的信号处理函数：由于突然闯进来，一般把事件登记在队列，然后返回该进程原来在做的事
  - 若进程在内核态，那通知挂起、
- 同步阻塞IO不能同时重叠处理操作，但同步非阻塞和异步IO可以


### 3、阻塞、非阻塞、同步、异步
- 阻塞io会一直block对应的进程直到操作完成
- 非阻塞io在内核还在准备数据的情况下立刻返回
- 同步io是指在做io操作（真实的）的时候，会将process阻塞
  - 这么定义，blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO
- 本质没有关系
  - 同步与异步是关于指令执行顺序的
  - 阻塞非阻塞是关于线程与进程的
- 详解
  - 同步是指代码调用IO操作时，必须等待IO操作完成才返回
  - 异步是指代码调用IO操作时，不必等IO操作完成就返回
    - 异步则需要多线程，多CPU或者非阻塞IO的支持
  - 阻塞是指调用线程或者进程被操作系统挂起
  - 非阻塞是指调用线程或者进程不会被操作系统挂起
  
### 4、异步，同步与 IO，线程，进程，阻塞，非阻塞等的关系
- 单线程
  - 只有同步，IO都是阻塞的
- 多线程让非阻塞成为可能

# 5、另一种解释
### 5.1、同步和异步
- 同步：一个任务的完成需要依赖另外一个任务
- 异步：是不需要等待被依赖的任务完成
- 消息通知
  - 当同步调用发出，调用者要等待消息（结果）通知后，才能继续；当异步过程调用发出，调用者不能立刻得到返回消息（结果）
- 场景：银行办理业务，排队等候（同步），取号等待（异步）

### 5.2、阻塞和非阻塞
- 阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关
- 场景：延续上面例子，如果排队或是取号过程中，不能做别的事就是阻塞。


### 5.3、组合
- 同步阻塞：这个线程在等待函数返回，没有执行其他消息处理
  - 专心排队，什么事都不做
- 同步非阻塞：这个线程在等待函数返回，仍在执行其他消息处理
  - 边玩自己边抬头看到自己没有
- 异步阻塞：异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞
  - 取号等待，但不能离开银行，阻塞在等待这个操作上面
- 异步非阻塞：函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理
  - 取号想出去抽烟，告诉大堂经理号到了叫自己（注册回调函数）
- 同步和阻塞
  - 比如读写操作，这里消息是指：fd是否可读写。如果是非阻塞，会直接返回fd是否可读写，那么读写操作不会在等待消息通知里阻塞
- 异步和非阻塞  
  - 异步操作一般不会在真正的IO操作阻塞，比如select函数，当select返回可读时再去读一般不会阻塞，而是在select函数调用处阻塞

### 5.4、究极场景：小明下载电影
- 同步阻塞：小明盯着下载进度条，直到100%
  - 同步：等待下载完成通知
  - 阻塞：等待过程中不能做其他事
- 同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条。
  - 同步：等待下载完成通知
  - 非阻塞：可干别的事（小明必须在这两个任务间切换）
- 异步阻塞：下载完有叮的一声，小明一直等待声音
  - 异步：叮的一声通知
  - 阻塞：不能做其他事
- 异步非阻塞：下载完有叮的一声，小明去干别的事
  - 异步：叮的一声通知
  - 非阻塞：可以干别的事（不需关注进度，只需接收软件“叮”声通知，即可）
- 同步/异步是“下载完成消息”通知的方式（机制），阻塞和非阻塞是等待通知过程中的状态
  - 同步是处理消息者自己去等待消息是否触发
  - 异步是由某些触发机制通知处理者。

### 6、I/O多路复用之select、poll、epoll
- select
  - 函数监视的文件描述符有writefds、readfds、和exceptfds。
  - 调用select会立即阻塞，直到有描述符就绪
  - 可以设置超时参数，以达到立即返回
  - 缺点
    - 连接数受限
    - 查找配对速度慢
    - 数据由内核拷贝到用户态
- poll
  - 